<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB R2019a"><title>Matlab Bootcamp</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S1 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 28.7999992370605px; min-height: 0px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: normal; text-align: left;  }
.S2 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: bold; text-align: left;  }
.S3 { margin: 10px 0px 20px; padding-left: 0px; font-family: Helvetica, Arial, sans-serif; font-size: 14px;  }
.S4 { margin-left: 56px; line-height: 21px; min-height: 0px; text-align: left; white-space: pre-wrap;  }
.CodeBlock { background-color: #F7F7F7; margin: 10px 0 10px 0;}
.S5 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 0px none rgb(0, 0, 0); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 17.234001159668px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S6 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 17.234001159668px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S7 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 1px solid rgb(233, 233, 233); border-bottom: 1px solid rgb(233, 233, 233); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 17.234001159668px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S8 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: bold; text-align: left;  }
.S9 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }
.S10 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }
.S11 { border-left: 1px solid rgb(233, 233, 233); border-right: 1px solid rgb(233, 233, 233); border-top: 0px none rgb(0, 0, 0); border-bottom: 0px none rgb(0, 0, 0); border-radius: 0px; padding: 0px 45px 0px 13px; line-height: 17.234001159668px; min-height: 18px; white-space: nowrap; color: rgb(0, 0, 0); font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; font-size: 14px;  }
.S12 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: bold; text-align: left;  }
.S13 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(0, 0, 0); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: normal; text-align: left;  }</style></head><body><div class = rtcContent><h1  class = 'S0'><span style=' font-weight: bold; text-decoration: underline;'>Matlab Bootcamp</span></h1><h1  class = 'S1'><span>Recap</span></h1><h4  class = 'S2'><span>Numeric Arrays</span></h4><ul  class = 'S3'><li  class = 'S4'><span>e.g. list of phone numbers</span></li><li  class = 'S4'><span>B = [4670456, 7640600, 123456];</span></li></ul><h4  class = 'S2'><span>Matrices</span></h4><ul  class = 'S3'><li  class = 'S4'><span>e.g. list of GPS coordinates</span></li><li  class = 'S4'><span>A  = [42.3086,-83.6921; 82.208, 23.692];</span></li></ul><h4  class = 'S2'><span>Cell Arrays</span></h4><ul  class = 'S3'><li  class = 'S4'><span>e.g. list of names</span></li><li  class = 'S4'><span>C = {'Duck','Goose','Crane'};</span></li></ul><h1  class = 'S1'><span>Matrix Manipulation</span></h1><h4  class = 'S2'><span>Adding a scalar to an array</span></h4><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>A = [1;2;3;4];</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>A + 3</span></span></div></div></div><h4  class = 'S2'><span>Adding two arrays</span></h4><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>B = [3;4;5;6];</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>A + B</span></span></div></div></div><h4  class = 'S2'><span>Element-wise multiplication</span></h4><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>A.*B</span></span></div></div></div><h4  class = 'S2'><span>Matrix multiplication</span></h4><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>C = [5 10 15 20];</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>A*C</span></span></div></div></div><h2  class = 'S8'><span></span></h2><h1  class = 'S1'><span>Organizing variables into structures</span></h1><h3  class = 'S9'><span>Structures</span></h3><div  class = 'S10'><span>Structure arrays can be used to group related data together. The data is structure arrays is accessed by name.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>patient(1).name = </span><span style="color: rgb(160, 32, 240);">'Jane Smith'</span><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>patient(1).age = 28;</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>patient(1).results = [68, 70, 68; 72, 81, 69; 172, 170, 169];</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>patient(1)</span></span></div></div></div><h3  class = 'S12'><span>Tables</span></h3><div  class = 'S10'><span>Tables are used for storing data in rows and column-oriented variables.</span></div><ul  class = 'S3'><li  class = 'S4'><span>Tables can contain different data types, such as strings and doubles</span></li><li  class = 'S4'><span>Each variable in the table must have the same number of rows</span></li></ul><div  class = 'S10'><span>Use </span><span style=' font-style: italic;'>readtable</span><span> to import example patient data and then </span><span style=' font-style: italic;'>summary to </span><span>examine its contents:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>T=readtable(</span><span style="color: rgb(160, 32, 240);">'patients.dat'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>summary(T)</span></span></div></div></div><div  class = 'S13'><span>Display data for the first four patients:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>T(1:4,:)</span></span></div></div></div><div  class = 'S13'><span>Now create a table that only includes the patient age, height and weight:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>T2=table(T.Age,T.Height,T.Weight);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>T2.Properties.VariableNames={</span><span style="color: rgb(160, 32, 240);">'Age'</span><span>,</span><span style="color: rgb(160, 32, 240);">'Height'</span><span>,</span><span style="color: rgb(160, 32, 240);">'Weight'</span><span>}</span></span></div></div></div><div  class = 'S10'><span></span></div><h1  class = 'S1'><span>Framington Heart Disease Dataset</span></h1><div  class = 'S10'><span>This dataset comes from a landmark study that analyzed ~14,000 people from three generations. The findings have informed the understanding of factors that impact cardiovascular health.  </span></div><div  class = 'S10'><span>Import the dataset and determine its size:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>fram = readtable(</span><span style="color: rgb(160, 32, 240);">'frmgham2.xls'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>size(fram)</span></span></div></div></div><div  class = 'S13'><span>The output of </span><span style=' font-style: italic;'>size </span><span>indiciates that the dataset includes 11,627 rows and 39 columns. Display the names of the 39 columns:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>fram.Properties.VariableNames</span></span></div></div></div><h3  class = 'S12'><span>Extracting Simple Properties</span></h3><div  class = 'S10'><span>Determine the mean, median and range of BMI:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>mean(fram.BMI)</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>median(fram.BMI)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>range(fram.BMI)</span></span></div></div></div><div  class = 'S13'><span>The mean and median functions return </span><span style=' font-style: italic;'>NaN </span><span>because there is data missing from the BMI array. MATLAB also has functions that ignore these missing data points:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>nanmean(fram.BMI)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>nanmedian(fram.BMI)</span></span></div></div></div><div  class = 'S10'><span>We will now look at extracting data from the framingham data set based on certain criteria. For example, what if we only want to examine individuals who smoke?</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>smoker_rows = fram.CURSMOKE==1;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>fram(smoker_rows,:)</span></span></div></div></div><div  class = 'S13'><span>Similarly, we can pick out individuals with a BMI above 30:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>BMI_rows = fram.BMI&gt;35;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>fram(BMI_rows,:)</span></span></div></div></div><div  class = 'S10'><span>This selection criteria method can also be applied to multiple variables at once:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>SMOKER_BMI_rows = fram.CURSMOKE==1 &amp; fram.BMI&gt;35;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>fram(SMOKER_BMI_rows,:)</span></span></div></div></div><div  class = 'S13'><span>By scrolling through the CURSMOKE and BMI columns of the above table, we can confirm that the new table only includes data for individuals that both smoked and have a BMI above 35. Now create a table which only includes the age, cholesterol and heartrate for these individuals:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>vars = {</span><span style="color: rgb(160, 32, 240);">'AGE'</span><span>,</span><span style="color: rgb(160, 32, 240);">'TOTCHOL'</span><span>,</span><span style="color: rgb(160, 32, 240);">'HEARTRTE'</span><span>};</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>new_table = fram(SMOKER_BMI_rows,vars)</span></span></div></div></div><div  class = 'S10'><span>We can also convert this table to a matrix, but we will lose the table headers, as MATLAB arrays can only contain one type of data.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>new_array = table2array(new_table)</span></span></div></div></div><h3  class = 'S12'><span>Manipulating Datasets</span></h3><div  class = 'S10'><span>As seen earlier in the BMI array, there are missing values throughout the dataset, which are signified by </span><span style=' font-style: italic;'>NaN. </span><span>It is important to know how to both find and replace these missing values.</span></div><div  class = 'S10'><span>We can use the </span><span style=' font-style: italic;'>find</span><span> and </span><span style=' font-style: italic;'>isnan </span><span>functions to determine the rows where data is missing:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>rows=find(isnan(fram.BMI))</span></span></div></div></div><div  class = 'S10'><span>Now we want to create a new array for BMI without the missing data points:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>new_BMI = fram.BMI;</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>new_BMI(</span><span class="warning_squiggle_rte warningHighlight">find</span><span>(isnan(fram.BMI)))=[];</span></span></div></div></div><div  class = 'S13'><span>To confirm that this worked, we can check that the size of the BMI array has decreased and that the </span><span style=' font-style: italic;'>mean </span><span>function now works:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>mean(new_BMI)</span></span></div></div></div><div  class = 'S10'><span>Now that the missing data points have been removed, sort the BMI array:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>sort(new_BMI)</span></span></div></div></div><div  class = 'S13'><span>We see that the default setting is to sort in ascending order, however there are multiple ways to use </span><span style=' font-style: italic;'>sort.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>sort(new_BMI,</span><span style="color: rgb(160, 32, 240);">'descend'</span><span>)</span></span></div></div></div><div  class = 'S10'><span>Next, let's look at the outliers in the BMI array:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>[TF,L,U,</span><span class="warning_squiggle_rte warningHighlight">C</span><span>] = isoutlier(new_BMI)</span></span></div></div></div><div  class = 'S13'><span>Similar to the </span><span style=' font-style: italic;'>isnan </span><span>function, </span><span style=' font-style: italic;'>isoutlier </span><span>creates a new array, </span><span style=' font-style: italic;'>TF, </span><span>and identify outlier points with ones. We can also see the lower and upper thresholds and the center value used to determine the outliers (variables L, U, and C). </span></div><div  class = 'S10'><span>We can also add new data to our table. Add the </span><span style=' font-style: italic;'>DIABETES</span><span> data to table </span><span style=' font-style: italic;'>T4:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>new_table.DIABETES = fram.DIABETES(SMOKER_BMI_rows)</span></span></div></div></div><h3  class = 'S12'><span> Simple Analyses of the Dataset</span></h3><div  class = 'S10'><span>We will now answer a few questions about the Framingam data set.</span></div><div  class = 'S10'><span style=' font-style: italic;'>1.) How many patients over 45 have a BMI over 40? </span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>patients = fram(fram.AGE&gt;45 &amp; fram.BMI&gt;40,[</span><span style="color: rgb(160, 32, 240);">"AGE"</span><span>,</span><span style="color: rgb(160, 32, 240);">"BMI"</span><span>]);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>size(patients)</span></span></div></div></div><div  class = 'S13'><span style=' font-style: italic;'>Another method:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>sum(fram.AGE&gt;45 &amp; fram.BMI&gt;40)</span></span></div></div></div><div  class = 'S10'><span></span></div><div  class = 'S10'><span style=' font-style: italic;'>2.) How data points are missing for the patient cholesterol? What is the median value for the cholesterol data that we do have?</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>numel(find(isnan(fram.TOTCHOL)))</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>nanmedian(fram.TOTCHOL)</span></span></div></div></div><div  class = 'S10'><span style=' font-style: italic;'>3.) Create a structure with all of the patient IDs and find the number of unique IDs.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>ID = fram.RANDID</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>num_ID = numel(ID)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>num_unq = numel(unique(ID))</span></span></div></div></div><h1  class = 'S0'><span>Importing and Exporting Datasets</span></h1><h3  class = 'S9'><span>Exporting</span></h3><div  class = 'S10'><span>As of MATLAB 2019, the write</span><span style=' font-style: italic;'>matrix </span><span>function is recommended for exporting datasets as opposed to previously used functions </span><span style=' font-style: italic;'>csvrwrite, xlswrite, </span><span>and </span><span style=' font-style: italic;'>dlmwrite</span><span>. </span><span style=' font-style: italic;'>writematrix </span><span>can be used with many different file types, such as .txt, .dat, .csv, and .xls. However, only numeric data can imported.</span></div><div  class = 'S10'><span> Write the array we made earlier, </span><span style=' font-style: italic;'>new_array, </span><span>to an Excel file:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>writematrix(new_array,</span><span style="color: rgb(160, 32, 240);">'new_array.xls'</span><span>)</span></span></div></div></div><div  class = 'S13'><span>Now do the same thing with </span><span style=' font-style: italic;'>new_table, </span><span>except write to a text file:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>writetable(new_table,</span><span style="color: rgb(160, 32, 240);">'new_table.txt'</span><span>,</span><span style="color: rgb(160, 32, 240);">'WriteRowNames'</span><span>,true)</span></span></div></div></div><h3  class = 'S12'><span>Importing</span></h3><div  class = 'S10'><span>Similar to exporting, the functions </span><span style=' font-style: italic;'>xlsread, dlmread, </span><span>and </span><span style=' font-style: italic;'>csvread </span><span>are no longer recommended in MATLAB 2019. Instead, you should use </span><span style=' font-style: italic;'>readtable </span><span>or </span><span style=' font-style: italic;'>readmatrix. </span><span>Import the .xls and .txt files that we just created:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>readmatrix(</span><span style="color: rgb(160, 32, 240);">"new_array.xls"</span><span>)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>readtable(</span><span style="color: rgb(160, 32, 240);">'new_table.txt'</span><span>)</span></span></div></div></div><h1  class = 'S0'><span>Handling Big Datasets</span></h1><h3  class = 'S9'><span>Head and Tail</span></h3><div  class = 'S10'><span>The </span><span style=' font-style: italic;'>head </span><span>and </span><span style=' font-style: italic;'>tail </span><span>functions can be used to view the first and last rows of a table or array. The default for </span><span style=' font-style: italic;'>heads </span><span>and </span><span style=' font-style: italic;'>tails </span><span>is to display the first and last eight rows, respectively. However, the number of rows can be altered for each function. Consider the framingham dataset we used earlier:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>first_rows = head(fram, 5)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>last_rows = tail(fram,3)</span></span></div></div></div><h3  class = 'S12'><span>Textscan</span></h3><div  class = 'S10'><span style=' font-style: italic;'>textscan </span><span>can be used to read data from a text file or string and insert it into a cell array. Below, we use </span><span style=' font-style: italic;'>textscan </span><span>to read the string </span><span style=' font-style: italic;'>chr </span><span>and use ' %f ' to indicate that we want to output double-precision floating-point numbers.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>chr = </span><span style="color: rgb(160, 32, 240);">'0.41 8.24 3.57 6.24 9.27'</span><span>;</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>C = textscan(chr,</span><span style="color: rgb(160, 32, 240);">'%f'</span><span>);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>celldisp(C)</span></span></div></div></div><h3  class = 'S12'><span></span></h3><h3  class = 'S9'><span>Sparces Matrices</span></h3><div  class = 'S10'><span>Sparse matrices are useful when your dataset is comprised of mostly zeros. As opposed to normal matrices which store every elemnt in the matrix, sparce matrices only store the nonzero elements along with their row indices. Sparce matrices therefor require much less memory for storage than full matrices.</span></div><div  class = 'S10'><span>The first step in creating a sparse matrix is determining the density on nonzero elements. The lower the density, the more it makes sense to create a sparce matrix. Consider the variables in the Framingham dataset which detail prevalent diseases:</span></div><ul  class = 'S3'><li  class = 'S4'><span>Prevalent Angina Pectoris (PREVAP)</span></li><li  class = 'S4'><span>Prevalent Coronary Heart Disease (PREVCHD)</span></li><li  class = 'S4'><span>Prevalent Myocardial Infarction (PREVMI)</span></li><li  class = 'S4'><span>Prevalent Stroke (PREVSTRK)</span></li><li  class = 'S4'><span>Prevalent Hypertensive (PREVHYP)</span></li></ul><div  class = 'S10'><span>The section of the data set containing these variables is mostly comprised of zeros. Create an array that includes these five variables, find the density, and find the memory required for the table.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>prev_table = fram(:,{</span><span style="color: rgb(160, 32, 240);">'PREVAP'</span><span>,</span><span style="color: rgb(160, 32, 240);">'PREVCHD'</span><span>,</span><span style="color: rgb(160, 32, 240);">'PREVHYP'</span><span>,</span><span style="color: rgb(160, 32, 240);">'PREVMI'</span><span>,</span><span style="color: rgb(160, 32, 240);">'PREVSTRK'</span><span>});</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>prev_array = table2array(prev_table)</span></span></div></div><div class="inlineWrapper"><div  class = 'S11'><span style="white-space: pre;"><span>nnz(prev_array) / numel(prev_array)</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>whos </span><span style="color: rgb(160, 32, 240);">prev_array</span></span></div></div></div><div  class = 'S10'><span>The memory required for the </span><span style=' font-style: italic;'>prev_array </span><span>variable is 465 kB. Now, convert </span><span style=' font-style: italic;'>prev_array </span><span>into a sparse matrix. You will see that the output is an array of the nonzero elements and their respective indeces, sorted by column. What happens to the requried storage space of the array?</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S5'><span style="white-space: pre;"><span>S = sparse(prev_array);</span></span></div></div><div class="inlineWrapper"><div  class = 'S6'><span style="white-space: pre;"><span>whos </span><span style="color: rgb(160, 32, 240);">S</span></span></div></div></div><div  class = 'S13'><span>The size of the array decreased to 117.4 kB, or about 25% of the original required memory. </span></div><div  class = 'S10'><span>If necessary, you can then convert the sparse matrix back into the full matrix with the </span><span style=' font-style: italic;'>full </span><span>command:</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>A = full(S)</span></span></div></div></div><div  class = 'S10'><span>It is also possible to create a sparse matrix directly from the nonzero elements, without needing the full matrix:</span></div><div  class = 'S10'><span style=' font-style: italic;'>S = sparse(i, j, s, m, n);</span></div><ul  class = 'S3'><li  class = 'S4'><span>i, j = row and column indices, respectively</span></li><li  class = 'S4'><span>s = vector of nonzero values with indices i, j</span></li><li  class = 'S4'><span>m, n = row and column dimensions of resulting matrix, respectively</span></li></ul><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre;"><span>sp = sparse([3 2 3 4 1],[1 2 2 3 4],[1 2 3 4 5],4,4)</span></span></div></div></div><h1  class = 'S0'></h1></div>
<br>
<!-- 
##### SOURCE BEGIN #####
%% *Matlab Bootcamp*
%% Recap
% Numeric Arrays
%% 
% * e.g. list of phone numbers
% * B = [4670456, 7640600, 123456];
% Matrices
%% 
% * e.g. list of GPS coordinates
% * A  = [42.3086,-83.6921; 82.208, 23.692];
% Cell Arrays
%% 
% * e.g. list of names
% * C = {'Duck','Goose','Crane'};
%% Matrix Manipulation
% Adding a scalar to an array

A = [1;2;3;4];
A + 3
% Adding two arrays

B = [3;4;5;6];
A + B
% Element-wise multiplication

A.*B
% Matrix multiplication

C = [5 10 15 20];
A*C
%% 
%% Organizing variables into structures
% Structures
% Structure arrays can be used to group related data together. The data is structure 
% arrays is accessed by name.

patient(1).name = 'Jane Smith';
patient(1).age = 28;
patient(1).results = [68, 70, 68; 72, 81, 69; 172, 170, 169];
patient(1)
% Tables
% Tables are used for storing data in rows and column-oriented variables.
%% 
% * Tables can contain different data types, such as strings and doubles
% * Each variable in the table must have the same number of rows
%% 
% Use _readtable_ to import example patient data and then _summary to _examine 
% its contents:

T=readtable('patients.dat');
summary(T)
%% 
% Display data for the first four patients:

T(1:4,:)
%% 
% Now create a table that only includes the patient age, height and weight:

T2=table(T.Age,T.Height,T.Weight);
T2.Properties.VariableNames={'Age','Height','Weight'}
%% 
% %% Framington Heart Disease Dataset
% This dataset comes from a landmark study that analyzed ~14,000 people from 
% three generations. The findings have informed the understanding of factors that 
% impact cardiovascular health.  
% 
% Import the dataset and determine its size:

fram = readtable('frmgham2.xls');
size(fram)
%% 
% The output of _size _indiciates that the dataset includes 11,627 rows and 
% 39 columns. Display the names of the 39 columns:

fram.Properties.VariableNames
% Extracting Simple Properties
% Determine the mean, median and range of BMI:

mean(fram.BMI)
median(fram.BMI)
range(fram.BMI)
%% 
% The mean and median functions return _NaN _because there is data missing from 
% the BMI array. MATLAB also has functions that ignore these missing data points:

nanmean(fram.BMI)
nanmedian(fram.BMI)
%% 
% We will now look at extracting data from the framingham data set based on 
% certain criteria. For example, what if we only want to examine individuals who 
% smoke?

smoker_rows = fram.CURSMOKE==1;
fram(smoker_rows,:)
%% 
% Similarly, we can pick out individuals with a BMI above 30:

BMI_rows = fram.BMI>35;
fram(BMI_rows,:)
%% 
% This selection criteria method can also be applied to multiple variables at 
% once:

SMOKER_BMI_rows = fram.CURSMOKE==1 & fram.BMI>35;
fram(SMOKER_BMI_rows,:)
%% 
% By scrolling through the CURSMOKE and BMI columns of the above table, we can 
% confirm that the new table only includes data for individuals that both smoked 
% and have a BMI above 35. Now create a table which only includes the age, cholesterol 
% and heartrate for these individuals:

vars = {'AGE','TOTCHOL','HEARTRTE'};
new_table = fram(SMOKER_BMI_rows,vars)
%% 
% We can also convert this table to a matrix, but we will lose the table headers, 
% as MATLAB arrays can only contain one type of data.

new_array = table2array(new_table)
% Manipulating Datasets
% As seen earlier in the BMI array, there are missing values throughout the 
% dataset, which are signified by _NaN. _It is important to know how to both find 
% and replace these missing values.
% 
% We can use the _find_ and _isnan _functions to determine the rows where data 
% is missing:

rows=find(isnan(fram.BMI))
%% 
% Now we want to create a new array for BMI without the missing data points:

new_BMI = fram.BMI;
new_BMI(find(isnan(fram.BMI)))=[];
%% 
% To confirm that this worked, we can check that the size of the BMI array has 
% decreased and that the _mean _function now works:

mean(new_BMI)
%% 
% Now that the missing data points have been removed, sort the BMI array:

sort(new_BMI)
%% 
% We see that the default setting is to sort in ascending order, however there 
% are multiple ways to use _sort._

sort(new_BMI,'descend')
%% 
% Next, let's look at the outliers in the BMI array:

[TF,L,U,C] = isoutlier(new_BMI)
%% 
% Similar to the _isnan _function, _isoutlier _creates a new array, _TF, _and 
% identify outlier points with ones. We can also see the lower and upper thresholds 
% and the center value used to determine the outliers (variables L, U, and C). 
% 
% We can also add new data to our table. Add the _DIABETES_ data to table _T4:_

new_table.DIABETES = fram.DIABETES(SMOKER_BMI_rows)
%  Simple Analyses of the Dataset
% We will now answer a few questions about the Framingam data set.
% 
% _1.) How many patients over 45 have a BMI over 40? _

patients = fram(fram.AGE>45 & fram.BMI>40,["AGE","BMI"]);
size(patients)
%% 
% _Another method:_

sum(fram.AGE>45 & fram.BMI>40)
%% 
% % 
% _2.) How data points are missing for the patient cholesterol? What is the 
% median value for the cholesterol data that we do have?_

numel(find(isnan(fram.TOTCHOL)))
nanmedian(fram.TOTCHOL)
%% 
% _3.) Create a structure with all of the patient IDs and find the number of 
% unique IDs._

ID = fram.RANDID
num_ID = numel(ID)
num_unq = numel(unique(ID))
%% Importing and Exporting Datasets
% Exporting
% As of MATLAB 2019, the write_matrix _function is recommended for exporting 
% datasets as opposed to previously used functions _csvrwrite, xlswrite, _and 
% _dlmwrite_. _writematrix _can be used with many different file types, such as 
% .txt, .dat, .csv, and .xls. However, only numeric data can imported.
% 
% Write the array we made earlier, _new_array, _to an Excel file:

writematrix(new_array,'new_array.xls')
%% 
% Now do the same thing with _new_table, _except write to a text file:

writetable(new_table,'new_table.txt','WriteRowNames',true)
% Importing
% Similar to exporting, the functions _xlsread, dlmread, _and _csvread _are 
% no longer recommended in MATLAB 2019. Instead, you should use _readtable _or 
% _readmatrix. _Import the .xls and .txt files that we just created:

readmatrix("new_array.xls")
readtable('new_table.txt')
%% Handling Big Datasets
% Head and Tail
% The _head _and _tail _functions can be used to view the first and last rows 
% of a table or array. The default for _heads _and _tails _is to display the first 
% and last eight rows, respectively. However, the number of rows can be altered 
% for each function. Consider the framingham dataset we used earlier:

first_rows = head(fram, 5)
last_rows = tail(fram,3)
% Textscan
% _textscan _can be used to read data from a text file or string and insert 
% it into a cell array. Below, we use _textscan _to read the string _chr _and 
% use ' %f ' to indicate that we want to output double-precision floating-point 
% numbers.

chr = '0.41 8.24 3.57 6.24 9.27';
C = textscan(chr,'%f');
celldisp(C)
% 
% Sparces Matrices
% Sparse matrices are useful when your dataset is comprised of mostly zeros. 
% As opposed to normal matrices which store every elemnt in the matrix, sparce 
% matrices only store the nonzero elements along with their row indices. Sparce 
% matrices therefor require much less memory for storage than full matrices.
% 
% The first step in creating a sparse matrix is determining the density on nonzero 
% elements. The lower the density, the more it makes sense to create a sparce 
% matrix. Consider the variables in the Framingham dataset which detail prevalent 
% diseases:
%% 
% * Prevalent Angina Pectoris (PREVAP)
% * Prevalent Coronary Heart Disease (PREVCHD)
% * Prevalent Myocardial Infarction (PREVMI)
% * Prevalent Stroke (PREVSTRK)
% * Prevalent Hypertensive (PREVHYP)
%% 
% The section of the data set containing these variables is mostly comprised 
% of zeros. Create an array that includes these five variables, find the density, 
% and find the memory required for the table.

prev_table = fram(:,{'PREVAP','PREVCHD','PREVHYP','PREVMI','PREVSTRK'});
prev_array = table2array(prev_table)
nnz(prev_array) / numel(prev_array)
whos prev_array
%% 
% The memory required for the _prev_array _variable is 465 kB. Now, convert 
% _prev_array _into a sparse matrix. You will see that the output is an array 
% of the nonzero elements and their respective indeces, sorted by column. What 
% happens to the requried storage space of the array?

S = sparse(prev_array);
whos S
%% 
% The size of the array decreased to 117.4 kB, or about 25% of the original 
% required memory. 
% 
% If necessary, you can then convert the sparse matrix back into the full matrix 
% with the _full _command:

A = full(S)
%% 
% It is also possible to create a sparse matrix directly from the nonzero elements, 
% without needing the full matrix:
% 
% _S = sparse(i, j, s, m, n);_
%% 
% * i, j = row and column indices, respectively
% * s = vector of nonzero values with indices i, j
% * m, n = row and column dimensions of resulting matrix, respectively

sp = sparse([3 2 3 4 1],[1 2 2 3 4],[1 2 3 4 5],4,4)
%%
##### SOURCE END #####
--></body></html>